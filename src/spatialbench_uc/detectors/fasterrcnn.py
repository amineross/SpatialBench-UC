"""
Faster R-CNN detector implementation using torchvision.

This detector uses the pre-trained Faster R-CNN model from torchvision,
which is trained on COCO and supports 80 object classes.

COCO class names are loaded from the auto-generated JSON file
(data/objects/coco_classes.json), which was extracted from torchvision's
pretrained weights metadata to ensure consistency.

This is a closed-vocabulary detector - it can only detect objects from
the COCO class list.
"""

import json
from functools import lru_cache
from pathlib import Path

import torch
from PIL import Image
from torchvision.models.detection import (
    fasterrcnn_resnet50_fpn_v2,
    FasterRCNN_ResNet50_FPN_V2_Weights,
)
from torchvision.transforms import functional as F

from spatialbench_uc.detectors.base import BaseDetector, Detection, DetectorConfig
from spatialbench_uc.detectors.registry import register_detector
from spatialbench_uc.utils.device import get_device


def _get_project_root() -> Path:
    """Get the project root directory."""
    # Navigate from src/spatialbench_uc/detectors/ to project root
    current = Path(__file__).resolve()
    # Go up: detectors -> spatialbench_uc -> src -> project_root
    return current.parent.parent.parent.parent


@lru_cache(maxsize=1)
def load_coco_classes() -> list[dict]:
    """
    Load COCO class information from the auto-generated JSON file.
    
    The JSON file is generated by scripts/generate_coco_vocab.py from
    torchvision's pretrained weights metadata.
    
    Returns:
        List of dicts with 'id', 'name', and 'is_background' for each class.
    
    Raises:
        FileNotFoundError: If the COCO classes JSON file doesn't exist.
            Run `python scripts/generate_coco_vocab.py` to generate it.
    """
    json_path = _get_project_root() / "data" / "objects" / "coco_classes.json"
    
    if not json_path.exists():
        raise FileNotFoundError(
            f"COCO classes file not found: {json_path}\n"
            "Please run: python scripts/generate_coco_vocab.py"
        )
    
    with open(json_path) as f:
        data = json.load(f)
    
    return data["classes"]


def get_coco_class_names() -> list[str]:
    """
    Get the list of valid COCO class names (excluding background and N/A).
    
    Returns:
        List of COCO class names that can be detected.
    """
    classes = load_coco_classes()
    return [
        c["name"] for c in classes 
        if not c["is_background"] and c["name"] != "N/A"
    ]


def get_coco_id_to_name() -> dict[int, str]:
    """
    Get a mapping from COCO class ID to class name.
    
    Returns:
        Dict mapping class ID to class name.
    """
    classes = load_coco_classes()
    return {c["id"]: c["name"] for c in classes}


def get_coco_name_to_id() -> dict[str, int]:
    """
    Get a mapping from COCO class name to class ID.
    
    Returns:
        Dict mapping class name (lowercase) to class ID.
    """
    classes = load_coco_classes()
    return {c["name"].lower(): c["id"] for c in classes if c["name"] != "N/A"}


@register_detector("fasterrcnn")
class FasterRCNNDetector(BaseDetector):
    """
    Faster R-CNN detector using torchvision pre-trained weights.

    This detector uses fasterrcnn_resnet50_fpn_v2 with COCO weights.
    It is a closed-vocabulary detector limited to COCO's 80 classes.
    
    Class names are loaded from the auto-generated JSON file
    (data/objects/coco_classes.json) which was extracted from torchvision.

    Example config:
        ```yaml
        detector:
          type: fasterrcnn
          params:
            score_threshold: 0.5
            device: auto
        ```
    """

    def __init__(self, config: DetectorConfig) -> None:
        """
        Initialize the Faster R-CNN detector.

        Args:
            config: Detector configuration with optional params.
        """
        self.config = config
        self.params = config.params or {}
        self.score_threshold = self.params.get("score_threshold", 0.5)

        # Model will be loaded lazily or in warmup()
        self._model = None
        self._device = None
        
        # Load class mappings
        self._id_to_name = get_coco_id_to_name()
        self._name_to_id = get_coco_name_to_id()

    def _load_model(self) -> None:
        """Load the Faster R-CNN model if not already loaded."""
        if self._model is not None:
            return
            
        # Get device from config or auto-detect
        device_pref = self.params.get("device", "auto")
        self._device = get_device(device_pref)
        
        # Load model with pretrained weights
        weights = FasterRCNN_ResNet50_FPN_V2_Weights.DEFAULT
        self._model = fasterrcnn_resnet50_fpn_v2(weights=weights)
        self._model.to(self._device)
        self._model.eval()

    def detect(self, image: Image.Image, labels: list[str]) -> list[Detection]:
        """
        Detect objects matching the given labels.

        Args:
            image: The input image as a PIL Image.
            labels: List of COCO class names to detect.

        Returns:
            List of Detection objects for matching instances.
        """
        self._load_model()
        
        # Convert labels to lowercase and get their COCO IDs
        target_labels = {label.lower() for label in labels}
        target_ids = {
            self._name_to_id[label] 
            for label in target_labels 
            if label in self._name_to_id
        }
        
        if not target_ids:
            # No valid COCO labels requested
            return []
        
        # Convert image to tensor
        # Ensure RGB mode
        if image.mode != "RGB":
            image = image.convert("RGB")
        
        img_tensor = F.to_tensor(image).to(self._device)
        
        # Run inference
        with torch.no_grad():
            outputs = self._model([img_tensor])[0]
        
        # Filter and convert results
        detections = []
        boxes = outputs["boxes"].cpu()
        scores = outputs["scores"].cpu()
        labels_out = outputs["labels"].cpu()
        
        for box, score, label_id in zip(boxes, scores, labels_out):
            label_id = int(label_id)
            score_val = float(score)
            
            # Filter by requested labels and score threshold
            if label_id not in target_ids:
                continue
            if score_val < self.score_threshold:
                continue
                
            # Get label name
            label_name = self._id_to_name.get(label_id, "unknown")
            
            detections.append(Detection(
                box_xyxy=tuple(float(x) for x in box.tolist()),
                score=score_val,
                label=label_name,
            ))
        
        return detections

    def warmup(self) -> None:
        """Preload the Faster R-CNN model."""
        self._load_model()

    def cleanup(self) -> None:
        """Release model resources."""
        if self._model is not None:
            del self._model
            self._model = None
            if self._device and self._device.type == "cuda":
                torch.cuda.empty_cache()

    @staticmethod
    def get_coco_classes() -> list[str]:
        """
        Get the list of valid COCO class names.
        
        Returns:
            List of COCO class names (excluding background and N/A).
        """
        return get_coco_class_names()

    def is_valid_class(self, class_name: str) -> bool:
        """
        Check if a class name is valid for this detector.
        
        Args:
            class_name: The class name to check.
            
        Returns:
            True if the class is in the COCO vocabulary.
        """
        return class_name.lower() in self._name_to_id

    def get_class_id(self, class_name: str) -> int | None:
        """
        Get the COCO class ID for a class name.
        
        Args:
            class_name: The class name to look up.
            
        Returns:
            The class ID, or None if not found.
        """
        return self._name_to_id.get(class_name.lower())

    def get_class_name(self, class_id: int) -> str | None:
        """
        Get the class name for a COCO class ID.
        
        Args:
            class_id: The class ID to look up.
            
        Returns:
            The class name, or None if not found.
        """
        return self._id_to_name.get(class_id)
